/*
 * mnn.c
 * The implementation of a pre-trained time-predictable meta neural network, generated by MNN2C.py.
 */

#include <stdbool.h>
#include "libcorethread/corethread.h"
#include "mnn.h"


#define DELAY_INPUTS_TO_DARKNET 1
#define DELAY_DARKNET_TO_OUTPUTS 1

// Cluster 0
// darknet's connection 0, from inputs
// Source range(s)
#define CONN_INPUTS_TO_DARKNET_0_DIM_0_START 0
#define CONN_INPUTS_TO_DARKNET_0_DIM_0_STOP 28
#define CONN_INPUTS_TO_DARKNET_0_DIM_1_START 0
#define CONN_INPUTS_TO_DARKNET_0_DIM_1_STOP 28
#define CONN_INPUTS_TO_DARKNET_0_DIM_2_START 0
#define CONN_INPUTS_TO_DARKNET_0_DIM_2_STOP 1
// Destination range(s) and length(s)
#define CONN_DARKNET_FROM_INPUTS_0_DIM_0_START 0
#define CONN_DARKNET_FROM_INPUTS_0_DIM_0_STOP 28
#define CONN_DARKNET_FROM_INPUTS_0_DIM_0_LEN 28
#define CONN_DARKNET_FROM_INPUTS_0_DIM_1_START 0
#define CONN_DARKNET_FROM_INPUTS_0_DIM_1_STOP 28
#define CONN_DARKNET_FROM_INPUTS_0_DIM_1_LEN 28
#define CONN_DARKNET_FROM_INPUTS_0_DIM_2_START 0
#define CONN_DARKNET_FROM_INPUTS_0_DIM_2_STOP 1
#define CONN_DARKNET_FROM_INPUTS_0_DIM_2_LEN 1
// Outputs
// outputs's connection 0, from darknet
// Source range(s)
#define CONN_DARKNET_TO_OUTPUTS_0_DIM_0_START 0
#define CONN_DARKNET_TO_OUTPUTS_0_DIM_0_STOP 1
// Destination range(s) and length(s)
#define CONN_OUTPUTS_FROM_DARKNET_0_DIM_0_START 0
#define CONN_OUTPUTS_FROM_DARKNET_0_DIM_0_STOP 1
#define CONN_OUTPUTS_FROM_DARKNET_0_DIM_0_LEN 1

void increment_index(int *index, int length)
{
    if (++(*index) >= length)
    {
        *index = 0;
    }
}


// Load and run functions
// Cluster 0
void run_unit_darknet(NN_META_DATA *mnn_data)
{
    int src_dim_0_index, src_dim_1_index, src_dim_2_index;
    int dst_dim_0_index, dst_dim_1_index, dst_dim_2_index;
    src_dim_0_index = CONN_INPUTS_TO_DARKNET_0_DIM_0_START;
    src_dim_1_index = CONN_INPUTS_TO_DARKNET_0_DIM_1_START;
    src_dim_2_index = CONN_INPUTS_TO_DARKNET_0_DIM_2_START;

    // Iterate over destination indices
    //#pragma loopbound min CONN_DARKNET_FROM_INPUTS_0_DIM_0_LEN max CONN_DARKNET_FROM_INPUTS_0_DIM_0_LEN
    for (dst_dim_0_index = CONN_DARKNET_FROM_INPUTS_0_DIM_0_START; dst_dim_0_index < CONN_DARKNET_FROM_INPUTS_0_DIM_0_STOP; dst_dim_0_index++)
    {
        //#pragma loopbound min CONN_DARKNET_FROM_INPUTS_0_DIM_1_LEN max CONN_DARKNET_FROM_INPUTS_0_DIM_1_LEN
        for (dst_dim_1_index = CONN_DARKNET_FROM_INPUTS_0_DIM_1_START; dst_dim_1_index < CONN_DARKNET_FROM_INPUTS_0_DIM_1_STOP; dst_dim_1_index++)
        {
            //#pragma loopbound min CONN_DARKNET_FROM_INPUTS_0_DIM_2_LEN max CONN_DARKNET_FROM_INPUTS_0_DIM_2_LEN
            for (dst_dim_2_index = CONN_DARKNET_FROM_INPUTS_0_DIM_2_START; dst_dim_2_index < CONN_DARKNET_FROM_INPUTS_0_DIM_2_STOP; dst_dim_2_index++)
            {
                mnn_data->darknet.inputs[dst_dim_0_index][dst_dim_1_index][dst_dim_2_index] =
                    mnn_data->inputs[mnn_data->darknet_pl_conn_0_inputs][src_dim_0_index][src_dim_1_index][src_dim_2_index];
    
                src_dim_2_index++;
                if (!(src_dim_2_index < CONN_INPUTS_TO_DARKNET_0_DIM_2_STOP))
                {
                    src_dim_2_index = CONN_INPUTS_TO_DARKNET_0_DIM_2_START;
                    src_dim_1_index++;
                    if (!(src_dim_1_index < CONN_INPUTS_TO_DARKNET_0_DIM_1_STOP))
                    {
                        src_dim_1_index = CONN_INPUTS_TO_DARKNET_0_DIM_1_START;
                        src_dim_0_index++;
                    }
                }
            }
        }
    }

    // assert(src_dim_0_index == CONN_INPUTS_TO_DARKNET_0_DIM_0_STOP);
    increment_index(&mnn_data->darknet_pl_conn_0_inputs, NN_META_IN_PL_LEN);

    nn_run_darknet(&mnn_data->darknet);
}


void run_cluster_0(NN_META_DATA *mnn_data)
{
    run_unit_darknet(mnn_data);
}


void copy_outputs(NN_META_DATA *mnn_data)
{
    int src_dim_0_index;
    int dst_dim_0_index;

    // Copy unit outputs to MNN outputs
    src_dim_0_index = CONN_DARKNET_TO_OUTPUTS_0_DIM_0_START;

    // Iterate over destination indices
    //#pragma loopbound min CONN_OUTPUTS_FROM_DARKNET_0_DIM_0_LEN max CONN_OUTPUTS_FROM_DARKNET_0_DIM_0_LEN
    for (dst_dim_0_index = CONN_OUTPUTS_FROM_DARKNET_0_DIM_0_START; dst_dim_0_index < CONN_OUTPUTS_FROM_DARKNET_0_DIM_0_STOP; dst_dim_0_index++)
    {
        mnn_data->outputs[dst_dim_0_index] =
            mnn_data->darknet.outputs[mnn_data->outputs_pl_conn_0_darknet][src_dim_0_index];
    
        src_dim_0_index++;
    }

    // assert(src_dim_0_index == CONN_DARKNET_TO_OUTPUTS_0_DIM_0_STOP);
    increment_index(&mnn_data->outputs_pl_conn_0_darknet, DARKNET_MAX_PL_LEN);
}


void tick_controller(WORKER_DATA *worker_data, int status)
{
    int worker_index;

    // Wait for all workers to arrive
    for (worker_index = 0; worker_index < WORKER_COUNT; worker_index++)
    {
        while (!worker_data->worker_flags[worker_index])
        {
            inval_dcache();
        }
    }  

    // Set status
    worker_data->status = status;

    // Reset flags
    for (worker_index = 0; worker_index < WORKER_COUNT; worker_index++)
    {
        worker_data->worker_flags[worker_index] = false;
    }

    // Toggle barrier, releasing workers
    worker_data->tick_barrier = !worker_data->tick_barrier;
}


void tick_worker(WORKER_DATA *worker_data, int id)
{
    int barrier_sample = worker_data->tick_barrier;

    // Mark self as arrived
    worker_data->worker_flags[id] = true;

    // Wait for a signal from the controller (a change in tick_barrier value)
    while (worker_data->tick_barrier == barrier_sample)
    {
        inval_dcache();
    }
}


int mnn_init(NN_META_DATA *mnn_data)
{
    nn_init_darknet();
    
    // Input
    mnn_data->input_pl_index = 0;
    // Cluster 0
    mnn_data->darknet_pl_conn_0_inputs = (NN_META_IN_PL_LEN - DELAY_INPUTS_TO_DARKNET) % NN_META_IN_PL_LEN;
    // Output
    mnn_data->outputs_pl_conn_0_darknet = DARKNET_MAX_PL_LEN - DELAY_DARKNET_TO_OUTPUTS;

    mnn_data->worker_data.status = STATUS_RUNNING;

    return 0;
}


int mnn_response(NN_META_DATA *nn_data)
{
    increment_index(&nn_data->input_pl_index, NN_META_IN_PL_LEN);
    copy_outputs(nn_data);
    
    run_cluster_0(nn_data);

    tick_controller(&nn_data->worker_data, STATUS_RUNNING);
    return nn_data->input_pl_index; // The buffer to which new input data must be written
}


void mnn_free(NN_META_DATA *mnn_data)
{
    tick_controller(&mnn_data->worker_data, STATUS_FINISHED);

    int *ret;
    for (int worker_index = 0; worker_index < WORKER_COUNT; worker_index++)
    {
        corethread_join(worker_index + 1, (void **)&ret);
        if (ret != NULL)
        {
            printf("Worker exited with unexpected return status: %p", ret);
            exit(1);
        }
    }
}